## 2021/3/16
### Radix NewCluster() 동작 파악
1. cluster를 생성할때 host 정보와 함께 실행할 cluster operation을 받는다.
2. 기본적으로 실행되어야 하는 default operation을 실행하고, 인자로 받은 operation을 실행한다.
3. default operation : default pool 생성 함수 지정, cluster sync 주기 설정, cluster down state 기준 설정

## 2021/3/17
### Radix connection 관리
처음 cluster와의 connection을 생성할 때나, client를 이용해 작업을 수행할때 non-application level의 에러(timeout, disconnect, ...)가 발생하는 경우 자동으로 conn을 close한다.
-> lastIOErr에 최근 발생한 IO 에러를 저장하고, pool에 conn을 put할때 lastIOErr를 확인하여 not nil이면 close() 호출

## 2021/3/18
### leetcode 문제 풀이
Reverse Integer
32bit integer를 입력받고 뒤집어진(321 -> 123) 32bit integer를 출력하는 문제.
나누기 연산과 나머지 연산을 이용하여 나머지로 나눈 숫자를 결과에 더하고 자릿수를 늘려주는 방식으로 문제를 해결했다.
제한사항으로 뒤집어진 숫자가 32bit integer 범위를 넘어가면 0을 return해야한다는 부분이 있었는데, 
min, max값에서 나누기 10을 한 값과 더하려고하는 나머지 숫자를 확인해 min, max를 체크하여 처리.
처음엔 list에 넣어서 값을 처리했는데, 메모리 절약을 위해 리스트 안쓰는 형태로 다시 풀었다.

## 2021/3/19
### leetcode 문제풀이
Palindrome number
숫자가 회문인지 확인하는 함수를 짜는 문제. string 전환 후 reverse하여 기존 숫자와 같은지 확인하는 방식의 답이 많았는데, 문제 조건에서 integer 그대로 변환하지 않은 상태에서 풀어보는 제약조건이 있었기에 그렇게 풀어보았다.
reverse integer와 거의 같은 방법으로 풀었다. 나누기 + 나머지 연산 하여 숫자를 뒤집고 그 숫자가 원 숫자와 같은지 확인
썩 빠른 방법은 아니었기때문에, 다른 방법이 있는지 찾아보아야함.

## 2021/3/20
### leetcode Longest common prefix(easy)
주어진 string slice에 대하여 가장 긴 prefix를 출력하는 문제.
horizontal scanning과 같은 방식으로 index 0부터 모든 string[i]를 비교하여 완전 일치할때마다 저장하는 방식으로 처리하였다.(가장 간단한 방식으로 풀었음.)
해답에서는 Divide & conquer나 binary search등의 방식으로 풀이했는데, 실제로 complexity가 얼마나 차이나는지 비교해 보아야함.
golang이 기본적으로 성능이 빨라서 상대적으로 얼마나 느린지가 잘 측정이 안되는 상황.

## 2021/3/21
### leetcode Roman to integer(easy)
주어진 Roman 숫자를 integer로 변환하는 문제.
기본적으로 I -> 1, X -> 10, V -> 5 처럼 문자와 숫자가 1:1 매핑되어있어 변환하여 전부 더해주면 된다.
그러나 어떤 문자 왼편에 숫자와 조합하는 경우 숫자의 의미가 조금 다르게 해석될 여지가 있어 그부분을 처리해주어야한다.
예를들면 4를 표시할때 IIII가 아니라 IV라는 방식으로 표현하기때문에, 이를 처리해주어야한다.
hint에서 알려주듯이 로만 문자 오른쪽에서부터 순차적으로 문자를 하나씩 변환하여 더해주면 문제 풀기가 수월하다.
처음에는 예외처리할 문자를 일일이 확인하여 뺄셈을 해주었는데, 보통 왼쪽으로 갈수록 숫자가 커지는데 왼쪽 숫자가 오른쪽 숫자보다 작은 경우가(IV -> 1 < 5 -> 4) 
예외처리 해주어야하는 특이케이스인 것을 이용하여 왼쪽 숫자가 오른쪽 숫자보다 작은경우 뺄셈을, 아닌경우 덧셈을 사용해주면 좀더 간단하게 문제풀이가 가능하다.
문자 맨 끝은 오른쪽 문자를 볼필요 없으니 처음에 초기값으로 구해주면 편하고, 모든 경우에 전부 옆 문자를 확인하기보다 특정 문자(I,X,C)가 들어왔을때만 확인하도록 하는 것이 속도를 조금 더 단축시킬 수 있다.

## 2021/3/22
### leetcode Valid parentheses(easy)
괄호를 validation 하는 문제.
소, 중, 대괄호가 적절하게 열고 닫혔는지 검증하여야한다.
각각의 open 괄호가 등장했을때 stack에 push하고, close 괄호가 등장할때 pop해서 pop된 char가 적절한 char인지 검증하면 된다.
stack을 pop할때 길이에 주의해야한다.